<!DOCTYPE html>

<head>
    <link rel="stylesheet" type="text/css" href="paper.css">
    <title>HTTP 2 explained</title>
</head>

<body>
    <h1>1. Какво е HTTP? </h1>

    <img src="images/HTTP-Protocol.png" alt="HTTP request and response">

    <p>HTTP е мрежов протокол от приложния слой на OSI модела, служещ за обмяна на информация и ресурси в компютърни
        мрежи. Доказва се като много успешен през годините. С времето обаче се оказва, че начинът, по който по-старите
        версии на HTTP (1.0, 1.1) използват транспортния слой под себе си, е неефикасен и не отговаря на нуждите на
        модерния свят. Казано по-просто, мрежата, по която се пренасят HTTP съобщенията се натоварва излишно много и
        това води до проблеми.
    </p>

    <h1>2. Какви всъщност са недостатъците на HTTP/1.1 и HTTP/1.0? </h1>

    <p>За да бъда по-конкретен, нека да се върнем малко в историята.<br>
        Първите версии на HTTP са били създадени, търсейки простота. За жалост, тази простота е била за сметка на
        производителността на приложенията. Какви всъщост са проблемите?
    </p>

    <ul>
        <li>HTTP/1.0 позволява само и единствено една заявка да преминава през изградена TCP конекция. Това очевидно
            струва доста скъпо - всеки път, когато изпращаме заявка, трябва да преминаваме през изграждане на TCP връзка
            - т.нар. three-way handshake. <br>
            HTTP/1.1 частично се справи с този проблем чрез <b><a
                    href="https://en.wikipedia.org/wiki/HTTP_pipelining">HTTP pipelining</a></b>. Накратко това ни
            позволява да изпращаме
            няколко заявки през една и съща TCP конекция (както се вижда на втората снимка - заявката на HTTP/1.1
            изисква снимка на къщата и колата, преди да се сложи край на конекцията). Все още обаче го има проблема с
            <b><a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">Head-of-line blocking (HOL
                    blocking)</a></b>.

            <p>
                Заради това клиентите, използващи HTTP/1.x, които искат да изпращат <b>много</b> заявки към
                даден сървър, са принудени да изграждат няколко TCP конекции към сървъра, за да постигнат конкурентност
                на заявките (търсейки намаляване на <a href="http://www.linfo.org/latency.html">латенцията</a>).
            </p>
        </li>

        <img src="images/http2-changes-everything-4-638.jpg" alt="HTTP: 1.1 vs 1.0" height="450" width="650">
        <img src="images/http2-changes-everything-5-638.jpg" alt="HTTP: 1.1 vs 1.0" height="450" width="650">

        <li>
            HTTP хедърите (header fields) доста често са многословни и повтарящи се, което причинява ненужно
            натоварване на мрежовия трафик, както и препълване на т.нар.
            <a href="https://en.wikipedia.org/wiki/TCP_congestion_control#Congestion_window">TCP congestion
                window</a> доста бързо.
        </li>
    </ul>

    <p>
        Тези проблеми не са били фатални, но с времето уеб приложенията са започнали да разширяват обхвата си, да стават
        по-сложни, както и по-важни за нас, хората. По-този начин отежниха задачата на самите
        потребителите на уеба, както и на уеб разработчиците. Точно това се опитва да олекоти HTTP/2.
    </p>

    <p>
        HTTP/2 се справя с тези проблеми, без да променя семантиката на протокола. Просто оптимизира начина, по който
        съобщенията се пренасят по транспортния слой/мрежата. Оптимизаците включват <b>мултиплексиране</b> на заявки и
        отговори (requests and responses) в една TCP конекция посредством т.нар. <b>streams</b>, както и
        <b>приоритизирането</b> на заявки - това позволява
        по-важните заявки да приключват по-бързо, което в крайна сметка подобрява производителността.
        <br><br>
        В крайна сметка HTTP/2 щади повече мрежата, защото се използват по-малко TCP конекции в сравнение с HTTP/1.x.

        Също така HTTP/2 обработва съобщенията по-ефикасно, използвайки т.нар. <b>binary framing layer</b>
    </p>

    <img src="images/http2-changes-everything-13-638.jpg" alt="HTTP timeline" height="450">

    <h1>3. Какво е HTTP/2? </h1>

    <p>
        HTTP/2 е оптимизация на HTTP/1.1, позволяваща по-добро използване на мрежовите ресурси. Основната цел му е чрез
        нови способи за пренос на данни по мрежата, да се ускори времето за зареждане на дадена уеб страница.
        Предимствата на HTTP/2 са неща като по-добро управление на връзката, ниско потребление на трафик, бързодействие.
        Семантично по никакъв начин не се различава от HTTP/1.1. Всички основни концепции, като HTTP methods, status
        codes, URIs, headers fields, си остават същите.
        Разликата е в това как самите данни се форматират и пренасят между клиента и сървъра.
        <br>В резултат на това всички приложения, които
        използват HTTP/1.1 могат да преминат към HTTP/2 без модификации.

        <h2>Основни начини, по които HTTP 2 постига по-добра ефикасност:</h2>
        <ul>
            <li>Request and response multiplexing in one TCP connection</li>
            <li>Compression of HTTP header fields</li>
            <li>Support for request prioritization</li>
            <li>Server push</li>
        </ul>

        <p>За да могат да се имплементират изброените по-горе feature-и, са използвани много подобрения на самия
            протокол - нов начин за flow control, error handling и upgrade mechanisms. Но гореописаните 4 неща са
            най-важните, които трябва да бъдат разбрани.
        </p>

    </p>

    <h1>Binary framing layer</h1>

    <p>
        В основата на подобренията на HTTP 2 е споменатият по-горе <b>binary framing layer</b>, който определя как
        съобщенията
        се изграждат и трансферират между клиента и сървъра.
    </p>

    <img src="images/binary_framing_layer01.svg" alt="binary framing layer" height="350" width="700">

    <p>
        Думата "layer" (слой) се отнася до изборът да се използва нов <b>механизъм за кодиране на съобщенията</b> между socket interface-а и
        HTTP API-то, с което нашите приложения работят. Семантиката на HTTP - verbs, methods и headers, не е засегната, но начинът, по който
        се кодира, докато се пренася по мрежата е различен. За разлика от HTTP/1.x, където имаме обикновен текст разделен с нови редове,
        всичката комуникация в HTTP/2 е разделена на по-малки messages и frames, като всяко от тях е кодирано в двоичен (binary) формат.
        <br><br>
        В резултат на този механизъм за кодиране, и клиентът, и сървърът трябва да 'знаят' и използват този механизъм, за да могат да се
        разбират. HTTP/1.x клиент няма да може да се разбере със сървър, поддържащ единствено HTTP/2, както и обратното. За щастие, нашите уеб
        приложения изобщо не е нужно да разбират за всички тези промени, тъй като HTTP клиентите и сървърите вършат работата 'зад завесите'.
    </p>

</body>